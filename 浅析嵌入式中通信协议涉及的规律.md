# 浅析嵌入式中通讯协议设计的规律

# 1. 概述

公司里做项目，嵌入式系统大大小小，到处都是。因为都是一个系统里的，所以都需要通讯，既然通讯就涉及到协议问题。

谈及协议，很多工程师觉得协议的设计相对简单，主要是报文的设计。大多数时候，协议的应用场景简单，没有复杂的交互。这么做的确也是没什么太大的问题。然而，就是这么简单的场景，仍有一些协议会在实际中发生意想不到的问题。归根结蒂，还是没有把握协议涉及的规律。下面我们简单的聊聊协议设计的规律。

# 2. 需要考虑的问题
协议设计中面临的问题：

>1. 设计者大多数情况下，从应用出发，仅仅考虑了基本需求的满足，没有考虑扩展需求的满足；
>2. 从osi七层理论上，我们往往设计的协议时站在比较高层的角度去设计，往往忽视了RS485/RS232, I2C, CAN, ETHERNET等物理层承载特点，设计缺乏对具体应用的针对性，导致潜在问题的产生；
>3. 容错和效率的考虑不足。

## 2.1. 可扩展性

### 2.1.1 兼容性
基本需求肯定是完成系统的基本功能。然而可能因为需求定义的不完整，系统设计人员没有前瞻性；协议中没有定义版本号，没有对协议兼容性的测试，导致老产品和新产品协议不兼容，而又无法采用简单的软件办法解决。这是个常见问题，最简单的办法是在握手协议中增加协议的版本号，用以判断是否对该协议支持以及为后续的软件做兼容准备。

### 2.1.2 静态和动态特性
协议看似好像只有报文设计，就像一个人一样，他在父母的眼里永远是个孩子，在自己的孩子面前是父母，在朋友面前是朋友。我相信所有这些侧面合起来才是一个完整的人。UML 从不同的角度去观察系统会得到不同的图。协议也是如此，协议的报文只是协议静态特性的一个方面，协议还有更重要的动态特性。如出错后怎么办，重发？重发几次？节点损坏如何从网络中剔除？怎么样才是一个完整的通讯过程？持续的时间是多少？最坏情况下是怎么样的？最好的情况下是什么样的？谁发起通讯？重要的协议可能要保证非常可靠，如何确定接受者接收的数据完全正确，并且可靠执行？往往这些问题已经超出了对报文自身的考虑，而是对系统解决方法的一种设计。这里有个小例子，一个RS485的半工通讯，主机向从机发送数据，希望从机可靠保存该数据；从机接收到该数据验证完毕后，写入自身的存储装置，然后再回应主机，写入成功或者失败。但这里有个问题，rs485是个主/从结构，无法同时发送数据，只能由主机点名从机回应。如果写入时间过长，从机回应报文的时间也必定过长；如果从机很多的话，这个时间就经不起浪费了。可能修改为，从机收到主机的信息后，立即应答收到。主机再分发其他从机的数据，分发完毕后，再由主机采用查询协议查询从机写入的成功与否。 当然，也可以采用一些系统级的办法，只要从机收到数据后，从机一定保证数据写入成功，那么这个问题也变得简单了。主机也不用再查询写入是否成功了。软件的设计也就相对简单很多。

## 2.2. 承载协议的硬件物理特性

> - **单工通信**
>
>   单工通信只有一根数据线，通信只在一个方向上进行，这种方式的应用实例有：监视器、打印机、电视机等。
>
> - **半双工通信**
>
>   半双工通信也只有一根数据线，它和单工的区别是这根数据线既可作发送又可作发接收，虽然数据可在两个方向上传送，但通信双方不能同时收发数据。
>
> - **全双工通信**
>
>   数据的发送和接收用两根不同的数据线，通信双方在同一时刻都能进行发送和接收，这一工作方式称为全双工通信。在这种方式下，通信双方都有发送器和接收器，发送和接收可同时进行，没有时间延迟。

### 2.2.1 串口
RS485/RS232也有双工通讯，但在实际中用得少。这里除了省线材之外，恐怕最重要的是因为RS485/RS232不带冲突检测，要么采用大家轮桩做主机，要么一个主机，点名让大家发言的办法。所以，通讯采用一问一答的方法比较多，这比较符合半工的工作状态。当然不排除一些双工的应用场景。实际应用中，大多数还是采用半工的办法。这里协议的设计主要考虑单点较多；多播和广播，因为不能确定从机是否接收成功，所以重要的协议在多播和广播之后还要查询，这个是很麻烦的事情。软件过程因此而复杂很多。RS485/RS232的通讯有自己的检测错误的办法，比如说奇偶校验，奇偶校验是一种简单的错误校验，并不能100%的挡住错误；对于可靠的协议，可能还是要设计自己的CRC或者校验和等方法。但CRC校验虽然可以用查表的办法，但计算时间比奇偶校验和校验和等方法计算量还是过大了些。在一些实时性和低端应用场合，可能时间开销大了些。所以，如果报文不是过大，还是可以考虑奇偶校验和校验和；如果过大，先考虑crc8，再考虑crc16和crc32，不要一竿子切。

### 2.2.2 I2C
I2C的通讯一般只用于板级，但现在也有用于现场总线的趋势。I2C设计之初是支持多主多从，两个主机可以同时发送信息，仲裁获胜的主机获得总线，继续发送。有仲裁不代表可以同时双向发送信息，即主机和从机的地位还是不同的，主机点名从机回应信息；虽然现在的CPU所带的I2C硬件同时支持主模式和从模式，但在同一时刻，这两个模式是不相容的。对于一个节点要么是主要么是从，而每次通讯都是由主发起，从被动接收，这就导致了和rs232无本质的区别。且，I2C的物理层协议也决定了，其通讯方式也没有rs232灵活，只能工作在半工状态。两个CPU传递一些简单的信息，在CPU无多余的rs232情况下，还是非常有用得。由于是板级的通讯，信号的完整性保证了以后，基本上不可能存在错误，也不需要额外的校验方法了。

>为什么I2C时序中未要求有校验位？

### 2.2.3 Ethernet和CAN
Ethernet和CAN总线类似，所有节点对等，无主从之说，谁都可以发起信息。由于冲突的检测，使得仲裁失败的节点稍后重试，物理层完成，不需要软件参与，因而给协议设计带来了极大的便利。比如说，先前的那个问题，一个广播协议出去，不再像 Rs232/rs485那样，再去一一查询确认。有问题的设备直接上报问题就好。大大的简便了问题的处理。RS232/RS485的节点如果发生问题，需要上报，也只能等到主机点名时才能有机会上报。Ethernet/Can就不用了，发生问题后，直接主动上传。可以确保问题和紧急情况的及时处理。如果Ethernet是基于TCP的协议，效率低了，但却保证了很多特性，数据的顺序到达，可靠性等等。IP 层以下的协议有很大的问题就是不能保证数据的顺序到达，多个路径的长短会影响协议到达的顺序，有些系统在设计时为了效率，采用UDP或者MAC层直接通讯。那么最好还是采用较为保守的策略，防止协议报文先后到达产生不必要的错误。Ethernet物理层 带有CRC32校验，自己再做校验实在没必要。

>CSMA/CD ?


## 2.3. 容错和效率
协议的效率是个较复杂的话题，以RS232为例，RS232如果1个起始位置，1个停止位置，没有奇偶校验。那么发送一个字节需要10Bit，对于9600bps的波特率，1秒钟最多传输960个字节。大约是1ms一个字节。如果停止位加长，协议一次性运送的有用的字节数还要更低。除去必要的帧头，帧尾，地址，校验信息，真正有用得信息除以总的总线上运送的字节数，就是协议的带载能力。很显然，如果我用多播和广播，明显地提高效率。对于RS232这种，广播也许并不是个好的选择，尤其是回头确认一遍。也许提高波特率是个不错的主意。这随之而来的问题是，1Mbps的通讯系统，1Start,1stop, non-parity, 1个字节只需要10us，这么快的中断不是普通的CPU能承受的。所以，可能需要DMA来接收。DMA 接收的话，就牵涉到变长的协议和定长的协议。变长的协议要动态的判断是否收到一个完整的包，而定长的协议，对于高速的RS232有无可比拟的优势。大大降低计算的复杂度。定长的协议就牵涉到协议的长度。我们一般把最频繁出现的协议的长度作为全部协议报文的长度。对于超长的协议，由于使用次数不多，拆成多条定长协议把报文完成。比如说，我们的系统控制命令长度为所有协议的长度，因为80%的协议报文都是系统控制命令。而20%的报文是其他出现频率较低的报文，如系统固件升级报文，本身固件的大小就很大，就算超长的报文也不可能容纳。砍成与控制命令报文等同的长度。看似比较零散，每包却都有各自独立性。都可以做单独的报文发送，前后的耦合性降到最低，也就是说，虽然大协议被拆分成小的等长协议报文，每个等长报文在发送过程中出错，可以单独再发送，整个通信序列无需重置。通过合理的设计，协议的效率自然而然的就被提升了。

>DMA?
>
>定长报文指什么?对于长度未达到指定长度的报文岂不是要做填充，那传输效率岂不是下降了？
>

Ethernet的设计相对宽松，其底层太强大了。很多工作都做了，所以，等长不等长对Ethernet系统无所谓。关键要解决Ethernet的通信模型问题。如果是嵌入式服务器，TCP 保持半开链接不能太耗费资源。如果是UDP或者mac层的协议，需要对协议序列的先后到达顺序进行解耦，防止出现不必要的问题。如果一个大协议包，需要拆成三个包发送，三个包顺序任意无影响；任意包发生错误，只需要将错误包重发成功即可。Ethernet由于速度高，协议带载能力可以得到很好的补充。另外，由于Ethernet是一个完美支持多播和广播的网络，实际中使用广播太多造成了广播风暴，导致网络性能急剧下降，所以现在分了虚拟局域网，就是为了抑制广播风暴，提高效率。实际使用中还是要尽量的合理设计系统，避免过多的广播协议的使用，以免拖慢整个网络系统。